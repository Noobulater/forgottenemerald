
Survive.Object = { }

local Object = Survive.Object

Object.validation = { }

function Object:New()
    local new = Clone(self)
    return new
end

function Object:GetGameObjectFromName( stype, name, ... )
    if(stype == ST_SGROUP)then
        return SGroup_FromName(name)
    elseif(stype == ST_EGROUP)then
        return EGroup_FromName(name)
    elseif(stype == ST_MARKER)then
        return Marker_FromName( name, ...)
    end
end

function Object:GameObjectExists(stype, name, ...)
    if(stype == ST_SGROUP)then
        return SGroup_Exists(name)
    elseif(stype == ST_EGROUP)then
        return EGroup_Exists(name)
    elseif(stype == ST_MARKER)then
        return Marker_Exists( name, ...)
    end
end

function Object:Validate(self, requirements, target)
	if (type(requirement) == "table") then
		for k, v in pairs(requirement) do
			if (type(v) == "table") and (type(v.name) == "string") then
				if (type(self.validation[v.name]) == "function") then
					if not (self.validation[v.name](self, v, target)) then
						return false
					end
				else
					PrintObject(v)
					fatal("Invalid Survive.Requirement data, function not found") 
				end
			else
				PrintObject(v)
				fatal("Invalid Survive.Requirement data, expected object was a table or object.name was a string, one failed")
			end
		end
		
		return true
	else
		PrintObject(requirement)
		fatal("Invalid Survive.Requirement data, expected Survive.Requirement passed in to be a table, got "..type(requirement))
	end
end

-- Example validation, assumes that self.group exists (this should be an Encounter validation, when encounters exist)
function Object.validation.IsNearEnemy(self, v, target)
	if (scartype(target) == ST_SGROUP) then
		local distance = params.distance or 10
		local enemyTeam = Player_GetTeam(Util_GetPlayerOwner(target))
		local sgroup = SGroup_CreateIfNotFound("temp_is_near_enemy")
		Team_GetAllSquadsNearMarker(enemyTeam, sgroup, Util_GetPosition(self.group), distance)
		if (SGroup_CountSpawned(sgroup) > 0) then
			Util_GroupDelete(sgroup)
			return true
		else
			Util_GroupDelete(sgroup)
			return false
		end
	else
		return false
	end
end

function Object:SpawnUnit(unit)
    local pos = unit.pos or unit.room:GetPosition()
    local sg = SGroup_Create("temp")
    Util_CreateSquadsAtMarker(unit.player, sg, unit.sbp, pos, 1)
    for k,v in pairs(unit.wargear)do 
        SGroup_EquipWargear( sg, v )
    end
    SGroup_AddGroup( unit.sgroup, sg )
end

function Object:PrintOnScreen(text, instance, duration, pos, color)
    text = text or 0
    duration = duration or 0
    
    pos = pos or {}
    pos.x = pos.x or 0.05
    pos.y = pos.y or 0.3
    
    color = color or {}
    color.r = color.r or 213
    color.g = color.g or 213
    color.b = color.b or 213
    
	instance = instance or tostring(self)
	dr_clear(instance)
	
	dr_setautoclear(instance, duration)
	dr_text2d(instance, pos.x, pos.y, text, color.r, color.g, color.b) 
end

function Object:PositionGetRandomOffset(position, radius)
	local posTable = { }
	local rotation = World_GetRand(0, 360)
	local randomRadius = World_GetRand(0, radius)
	posTable.z = (math.sin(rotation)*randomRadius) + position.z
	posTable.x = (math.cos(rotation)*randomRadius) + position.x
	
	return World_Pos(posTable.x, position.y, posTable.z)
end
