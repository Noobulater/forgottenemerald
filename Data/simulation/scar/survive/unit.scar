Survive.Unit = Survive.Object:New()
Survive.assets.unitNames = { }
Survive.assets.unitTags = { }
Util_LoadOnce("Survive//Data//Units.scar")
Util_LoadOnce("Survive//Data//Wargear.scar")
Util_LoadOnce("Survive//Behavior.scar")

local Unit = Survive.Unit

function Unit:New(player)
    local new = Clone(self)
	new.sgroup = SGroup_Create("")
	new.player = player
	new.team = Player_GetTeam(player)
	new.spawned = false
    return new
end

function Unit:Spawn(position, behaviors, modifiers)
	local numLoadout = self.data.loadout or nil
	PrintObject(self)
	Util_CreateSquadsAtMarker(self.player, self.sgroup, self.data.sbp, position, 1, numLoadout)
	self:SpawnSetup(behaviors, modifiers)
end

function Unit:SpawnFacingCenter(position, behaviors, modifiers)
	local numLoadout = self.data.loadout or nil
	local facing = World_Pos(0, position.y, 0)
	Util_CreateSquadsAtMarkerFacing(self.player, self.sgroup, self.data.sbp, position, facing, 1, numLoadout)
	self:SpawnSetup(behaviors, modifiers)
end

function Unit:SpawnFacing(position, facing, behaviors, modifiers)
	local numLoadout = self.data.loadout or nil
	facing = facing or World_Pos(0, position.y, 0)
	Util_CreateSquadsAtMarkerFacing(self.player, self.sgroup, self.data.sbp, position, facing, 1, numLoadout)
	self:SpawnSetup(behaviors, modifiers)
end

function Unit:SpawnSetup(behaviors, modifiers)
	self.spawned = true
	self:EquipWargear()
	self:SetBehaviors(behaviors)
	self:ApplyAttributes()
	self:ApplyModifiers(modifiers)
	self:RegisterEntities()
	self:FillEnergy()
	self:TeleportInAnimation()
	self:SpecialNPCRules()
	self:ApplyTeamColour()
	self:PlayOnSpawnActions()
	self.maxSquadSize = Squad_Count(SGroup_GetSpawnedSquadAt(self.sgroup, 1))
end

function Unit:GetRandom(player)
	local newUnit = Unit:New(player)
	local race = Player_GetRaceString(player)
	newUnit.data = Clone(Table_GetRandomItem(Survive.data.unitList))
	newUnit:Register()
	return newUnit
end

function Unit:GetPlayerUnit(player, data)
	local newUnit = Unit:New(player)
	local race = Player_GetRaceString(player)
	newUnit.data = Clone(data)
	newUnit.data.name = newUnit.data.name or Misc_GetPlayerName(player)
	return newUnit
end

function Unit:GetFromName(player, name, sender)
	local newUnit = Unit:New(player)
	local race = Player_GetRaceString(player)
	if (Survive.data.unitName[name]) then
		newUnit.data = Clone(Survive.data.unitName[name])
		newUnit:Register()
		return newUnit
	else
		fatal("Unit:GetUnitFromName received a bad name ("..tostring(name)..") of type ("..type(name)..")")
	end
end

function Unit:GetFromTag(player, tag, sender)
	local newUnit = Unit:New(player)
	local race = Player_GetRaceString(player)
	if (Survive.data.unitTag[tag]) then
		local rand = World_GetRand(1, #Survive.data.unitTag[tag])
		newUnit.data = Clone(Survive.data.unitTag[tag][rand])
		newUnit:Register()
		return newUnit
	else
		fatal("Unit:GetUnitFromTag received a bad tag ("..tostring(tag)..") of type ("..type(tag)..")")
	end
end

function Unit:SetTeamColour(colour)
	if (type(colour) == "table") and (not (colour.primary)) then
		colour.primary = colour.primaryColourName
		colour.secondary = colour.secondaryColourName
		colour.tint = colour.tintColourName
		colour.extra = colour.extraColourName
		colour.badge = colour.badgeColourPath
		colour.pattern = colour.patternColourName
		
		if self.data.Doppleganger_NoBadge == 1 then -- if this function was triggered via DoppleGanger...
			colour.badge = "data:art\\badges\\units\\nobadge" -- Then manually change badge to Index 60 (no badge)
		end
	end
	
	self.teamColour = colour
end

function Unit:ApplyTeamColour()
	if (type(self.teamColour) == "string") then
		for i=1, Util_CountGroup(self.sgroup) do 
			local squad = SGroup_GetSpawnedSquadAt(self.sgroup, i)
			Squad_SetTeamColourByChapter(squad, self.teamColour)
		end
	elseif (type(self.teamColour) == "table") then
		local c = self.teamColour
		for i=1, Util_CountGroup(self.sgroup) do
			local squad = SGroup_GetSpawnedSquadAt(self.sgroup, i)
			Squad_SetTeamColourByName(squad, c.primary, c.secondary, c.tint, c.extra, c.badge, c.pattern)
		end
		
		self:AddSpawnAction({action = function(self)
			Player_SetTeamColourByName( self.player, c.primary, c.secondary, c.tint, c.extra, c.badge, c.pattern )
			self.data.Doppleganger_NoBadge = 0 -- reset doppleganger badge so that it does not automatically remove the badge
		end})
	end
end

function Unit:GetBlueprintID()
    return self.data.sbp
end

function Unit:SetBehaviors(behaviors)
	if (type(behaviors) == "table") and (self:HasBehaviors()) then
		behaviors = MergeTables.Merge(self.data.behaviorList, behaviors, "string")
	elseif (type(behaviors) == "string") then
		print("this should not happen, function Unit:SetBehaviors")
		PrintObject(self)
	end

	if (self:HasBehaviors()) or (behaviors) then
		local rand = World_GetRand(1, 10)
		rand = rand*0.1
		self.behaviorList = behaviors or self.data.behaviorList
		Survive.Behavior.InitBehavior(self, rand, 1)
	end
end

function Unit:HasBehaviors()
    return((type(self.data.behaviorList) == "table") and (type(self.data.behaviorList[1]) == "table"))
end

function Unit:HasModifiers()
    return((type(self.data.modifiers) == "table") and (type(self.data.modifiers[1]) == "table"))
end

function Unit:HasSpawned()
	return self.spawned
end

function Unit:GetPoints()
	local points = self.data.points or 0
	if (points < 0) then points = 0 end
	self.data.loadout = self.data.loadout or Squad_GetDefaultSizeFromSBP(self.data.sbp)
	return self.data.loadout * points
end

function Unit:GetPointsLeft()
	if (self.spawned) then
		local total = 0
		local points = self.data.points or 0
		if (points < 0) then points = 0 end
		for i = 1, Util_CountGroup(self.sgroup) do
			local squad = SGroup_GetSpawnedSquadAt(self.sgroup, i)
			if (Squad_IsAnyConscious(squad)) then
				total = total + (Squad_Count(squad) * points)
			end
		end
		
		return total
	else
		return self:GetPoints()
	end
end

function Unit:IsDead()
	return SGroup_CountSpawned(self.sgroup) <= 0
end

function Unit:IsKO()
	local squadSpawnedCount = SGroup_CountSpawned(self.sgroup)
	if (squadSpawnedCount < 1) then return false end
    for i=1, squadSpawnedCount do
        local squad = SGroup_GetSpawnedSquadAt(self.sgroup, i)
        if (Squad_IsAnyConscious(squad)) then
            return false
        end
    end
    
    return true
end	

function Unit:GetPosition()
    return SGroup_GetPosition(self.sgroup)
end


function Unit:EquipWargear(wargear)
	local wargear = wargear or self.data.wargear
	if (type(wargear) == "table") then
		for k, v in pairs(wargear)do 
			if (type(v) == "string") and (string.len(v) > 5) then
				SGroup_EquipWargear( self.sgroup, v )
				if (type(Survive.data.wargear[v]) == "table")
				and (type(Survive.data.wargear[v].minion) == "table") then
					self.minionWargearData = self.minionWargearData or { }
					table.insert(self.minionWargearData, Clone(Survive.data.wargear[v].minion))
				end
			end
		end
	end
end

function Unit:UnequipAllWargear()
	local count = SGroup_GetEquippedWargearCount(self.sgroup)
	for i=1, count do
		local wargear = SGroup_GetEquippedWargear(self.sgroup, i)
		SGroup_UnequipWargear(self.sgroup, wargear)
	end
end

function Unit:SendCommand(...)
    Survive.Behavior.SendCommand(self, ...)
end

function Unit:ApplyAttributes(attributes)
	local attributes = attributes or self.data.attributes
	if (type(attributes) == "table") then
		for k, v in pairs(attributes) do
			SGroup_ModifyBonusAttribute(self.sgroup, v.type, v.level)
		end
	end
end

function Unit:ApplyModifiers(modifiers)
	local modifiers = modifiers or self.data.modifiers
	self.modifiers = { }
	if (type(modifiers) == "table") then
		for k, v in pairs(modifiers) do
			local modifier = v.modifier or fatal("Crawler Attempted to apply a Modifier without a modifier defined on "..self.data.name)
			local factor = v.factor or fatal("Crawler Attempted to apply a modifier without a factor defined on "..self.data.name)
			local mathtype = v.mathtype or MUT_Multiplication
			local applytype = v.applytype
			local exclusive = v.exclusive
			local targetname = v.targetname
			
			if (v.divideFactorBySquadSize) then
				factor = factor / Squad_Count(SGroup_GetSpawnedSquadAt(self.sgroup, 1))
			end
			self.modifiers[modifier] = self.modifiers[modifier] or { }
			table.insert(self.modifiers[modifier],
				Util_ApplyModifier(self.sgroup, modifier, factor, mathtype, applytype, exclusive, targetname)
			)
		end
	end
	
	self.modifiers[#self.modifiers+1] = Util_ApplyModifier(self.sgroup, "modifiers\\squad_modifiers\\experience_gained_squad_modifier", 0, MUT_Multiplication)
end

function Unit:AddWargearData()
	for i=1, SGroup_GetEquippedWargearCount(self.sgroup) do
		local wargear = SGroup_GetEquippedWargear(self.sgroup, i)
		
		self.data.abilities = self.data.abilities or { }
		if (type(Survive.data.wargear[wargear]) == "table") then
			if (type(Survive.data.wargear[wargear].abilities) == "table") then
				for k, v in pairs(Survive.data.wargear[wargear].abilities) do
					table.insert(self.data.abilities, v)
				end
			end
			
			if (type(Survive.data.wargear[wargear].behaviors) == "table") then
				for k, v in pairs(Survive.data.wargear[wargear].behaviors) do
					self:AddBehavior(v)
				end
			end
			
			if (type(Survive.data.wargear[wargear].wargear) == "table") then
				self:EquipWargear(Survive.data.wargear[wargear].wargear)
			end
		end
	end
end

function Unit:AddSquadData()
	local blueprint = Squad_GetBlueprintName(SGroup_GetSpawnedSquadAt(self.sgroup, 1))
	if (type(Survive.data.specialUnitData[blueprint]) == "table") then
		if (type(Survive.data.specialUnitData[blueprint].abilities) == "table") then
			for k, v in pairs(Survive.data.specialUnitData[blueprint].abilities) do
				local apply = true
				if (type(self.data.abilities) == "table") then
					for k2, v2 in pairs(self.data.abilities) do
						if (v.name == v2.name) then
							apply = false
						end
					end
				end
				self.data.abilities = self.data.abilities or { }
				if (apply) then
					table.insert(self.data.abilities, v)
				end
			end
		end
	end
end

function Unit:ApplyWargearMinionData()
	if (self.owner) and (type(self.owner.minionWargearData) == "table") then
		for dataKey, data in pairs(self.owner.minionWargearData) do
			if (type(data.modifiers) == "table") then
				self:ApplyModifiers(data.modifiers)
			end
			
			if (type(data.wargear) == "table") then
				self:EquipWargear(data.wargear)
			end
			
			if (type(data.deathActions) == "table") then
				for k, v in pairs(data.deathActions) do
					self:AddDeathAction(v)
				end
			end
			
			if (type(data.abilities) == "table") then
				self.data.abilities = self.data.abilities or { }
				for k, v in pairs(data.abilities) do
					table.insert(self.data.abilities, v)
				end
			end
		end
	end
end

function Unit:AddBehavior(behaviorData)
	Survive.Behavior.AddBehavior(self, behaviorData)
end

function Unit:Register()
	Survive.assets.unitNames[self.data.name] = Survive.assets.unitNames[self.data.name] or { }
	table.insert(Survive.assets.unitNames[self.data.name], self)
	
	if (type(self.data.tags) == "table") then
		for k, v in pairs(self.data.tags) do
			Survive.assets.unitTags[v] = Survive.assets.unitTags[v] or { }
			table.insert(Survive.assets.unitTags[v], self)
		end
	end
end

function Unit:RegisterEntities()
	local _register = function(groupid, itemindex, itemid)
		for i=0, Squad_Count(itemid)-1 do
			local entity = Squad_EntityAt(itemid, i)
			Survive.assets.entities[Entity_GetGameID(entity)] = self
		end
	end
	
	SGroup_ForEachEx(self.sgroup, _register, true, true)
end

function Survive.Unit.GetAllBlueprintsFromTag(tag)
	local blueprints = { }
	if (type(Survive.assets.unitTags[tag]) == "table") then
		for i=1, #Survive.assets.unitTags[tag] do
			blueprints[i] = Survive.assets.unitTags[tag][i].sbp
		end
	end
	return blueprints
end

function Unit:FillEnergy()
	local squad = SGroup_GetRandomSpawnedSquad(self.sgroup)
	Squad_ModifyEnergy(squad, 10000)
end

function Unit:GetRace()
	local raceTable = {
		[RACE_SPACEMARINE] = { search = "marine", deliver = RACE_SPACEMARINE, },
		[RACE_ELDAR] = { search = "eldar", deliver = RACE_ELDAR, },
		[RACE_ORK] = { search = "ork", deliver = RACE_ORK, },
		[RACE_IMPERIALGUARD] = { search = "imperial_guard", deliver = RACE_IMPERIALGUARD, },
		[RACE_TYRANID] = { search = "tyranid", deliver = RACE_TYRANID },
		[RACE_CHAOS] = { search = "Chaos", deliver = RACE_CHAOS },
		[RACE_TAU] = { search = "tau", deliver = RACE_TAU },
	    [RACE_NECRON] = { search = "necron", deliver = RACE_NECRON },
	}
	
	local str
	if (type(self.data.sbp) == "string") then
		str = self.data.sbp
	else
		str = World_GetPropertyBagGroupPathName(PBGTYPE_Squad, self.data.sbp)
	end
	
	for k, v in pairs(raceTable) do
		if (string.find(str, v.search)) then
			return v.deliver
		end
	end
end

-- Translates from the race name to the name used in the Art/Actions/Ability folder 
function Unit:GetArtAbilityRaceDirName()
    local race = self:GetRace()

	local raceNameTable = { 
        [RACE_ELDAR] = "Eldar", 
        [RACE_SPACEMARINE] = "Space_Marine", 
        [RACE_ORK] = "Ork", 
        [RACE_TYRANID] = "Tyranid", 
        [RACE_CHAOS] = "Chaos",
        [RACE_TAU] = "Tau",
        [RACE_NECRON] = "Necron" 
    }

	local racename = raceNameTable[race] or "Space_Marine"

    return racename
end

function Unit:TeleportInAnimation(object)
	if(self.useSpawnAnimation == false)then return end
	local object = object or self.sgroup
	local racename = self:GetArtAbilityRaceDirName()
	local teleportArrive = "Abilities\\"..racename.."\\teleport_arrive"
	
	Util_SetAnimatorAction(object, teleportArrive)
end

function Unit:TeleportOutAnimation(object)
	local object = object or self.sgroup
	local racename = self:GetArtAbilityRaceDirName()
	local teleportLeave = "Abilities\\"..racename.."\\teleport_leave"
	
	Util_SetAnimatorAction(object, teleportLeave)
end

function Unit:AwardPoints()
	local points = self.data.points or 1
	local totalPoints = math.floor((points*ScoreBoard.scoreModifier)*ScoreBoard:GetTotalMultiplier())
	if (points > -1) then
		local text = Loc_FormatText(9120325, self.data.locName, Loc_ConvertNumber(totalPoints))
		LastStand_AddKillKicker( text )
		ScoreBoard:AddPoints(totalPoints, tostring(self.data.name).." KILL")
	end
end

function Unit:SpecialNPCRules()
	if not (Misc_IsHumanPlayer(self.player)) then
		if (Player_GetID(self.player) == Player_GetID(Survive.data.enemyNPC)) then
			SGroup_SetSyncKillChanceOverride(self.sgroup, 1.0)
		end
		self:ApplyWargearMinionData()
		self:AddWargearData()
		self:AddSquadData()
	end
end

function Unit:RegisterMinion(minion)
	self.minionList = self.minionList or { }
	local id = minion.data.minionID or minion.data.name
	
	if (self.minionList[id]) then
		if (type(self.minionList[id].minionList) == "table") then
			for k, v in pairs(self.minionList[id].minionList) do
				v:Kill()
			end
		end
		self.minionList[id]:Kill()
	end
	
	minion:AddSpawnAction({ action = function(minion)
		UI_AddMinionTab( SGroup_GetSpawnedSquadAt( minion.sgroup, 1 ), SGroup_GetSpawnedSquadAt( self.sgroup, 1 ), -1 )
	end })
	
	self.minionList[id] = minion
	minion.owner = self
end

function Unit:CountAliveMinions()
	if (type(self.minionList) == "table") then
		local count = 0
		for k, v in pairs(self.minionList) do
			if (SGroup_CountSpawned(v.sgroup) > 0) then
				count = count + 1
			end
		end
		return count
	else
		return 0
	end
end

function Unit:PauseBehaviors()
	self.behavior = self.behavior or {}
	self.behavior.stateWaitTime = 99999
end

function Unit:UnPauseBehaviors()
	self.behavior = self.behavior or {}
	self.behavior.stateWaitTime = 0
end

function Unit:AreBehaviorsPaused()
	if (type(self.behavior) == "table") then
		return (self.behavior.stateWaitTime == 99999)
	else
		return false
	end
end

function Unit:AddSpawnAction(action)
	self.spawnActions = self.spawnActions or { }
	if (type(action) == "table") then
		table.insert(self.spawnActions, action)
	end
end

function Unit:PlayOnSpawnActions()
	if (type(self.spawnActions) == "table") then
		for k, v in pairs(self.spawnActions) do
			if (type(v.action) == "function") then
				v.action(self, v)
			end
		end
	end
end

function Unit:AddDeathAction(action)
	self.deathActions = self.deathActions or { }
	if (type(action) == "table") then
		table.insert(self.deathActions, action)
	end
end
function Unit:AddDeathActions(action)
	self.deathActions = self.deathActions or { }
	if (type(action) == "table") then
		for k,v in pairs(action) do 
			if(type(v) == "table")then
				table.insert(self.deathActions, v)
			end
		end
	end
end

function Unit:PlayDeathActions(entity)
	if (type(self.deathActions) == "table") then
		for k, v in pairs(self.deathActions) do
			v.action(self, entity, v)
		end
	end
end

function Unit:ActivateInvulnurableRage(duration)
	local entity = Squad_EntityAt(SGroup_GetSpawnedSquadAt(self.sgroup, 1), 0)
	
	if (self.endInvulnurableRageTime) then
		self.endInvulnurableRageTime = self.endInvulnurableRageTime + duration
	else
		Entity_SetSimVariable(entity, familyManager.sim_variable.invulnerable_rage, 1)
		self.endInvulnurableRageTime = World_GetGameTime() + duration + 1
		Rule_Add(function()
			if (World_GetGameTime() >= self.endInvulnurableRageTime) and (SGroup_CountSpawned(self.sgroup) > 0) then
				Entity_SetSimVariable(entity, familyManager.sim_variable.invulnerable_rage, 0)
				self.endInvulnurableRageTime = nil
				Rule_RemoveMe()
			elseif (SGroup_CountSpawned(self.sgroup) == 0) then
				Rule_RemoveMe()
			end
		end)
	end
end

function Unit:ReinforceMinions()
	if (type(self.minionList) == "table") then
		for k, v in pairs(self.minionList) do
			v:Reinforce()
		end
	end
end

function Unit:Reinforce()
	if (SGroup_CountSpawned(self.sgroup) > 0) then
		local squad = SGroup_GetSpawnedSquadAt(self.sgroup, 1)
		if (Squad_Count(squad) < self.maxSquadSize) then
			Cmd_ReinforceUnit(self.sgroup, 1)
			for i=0, Squad_Count(squad) - 1 do
				local entity = Squad_EntityAt(squad, i)
				if not (Survive.assets.entities[Entity_GetGameID(entity)]) then
					Survive.assets.entities[Entity_GetGameID(entity)] = self
					Util_SetAnimatorAction(entity, "ui\\abilities\\medkit")
					self:TeleportInAnimation(entity)
				end
			end
		end
	end
end

function Unit:HealMinions(amount)
	if (type(self.minionList) == "table") then
		for k, v in pairs(self.minionList) do
			v:Heal(amount)
		end
	end
end

function Unit:Heal(amount)
	if (SGroup_CountSpawned(self.sgroup) > 0) then
		local amount = amount or 0.05
		local squad = SGroup_GetSpawnedSquadAt(self.sgroup, 1)
		local numSquad = Squad_Count(squad)
		if (numSquad > 0) then
			for i=0, numSquad-1 do
				local entity = Squad_EntityAt(squad, i)
				local currentHealth = Entity_GetHealthPercentage(entity)
				if (currentHealth < 1) then
					local heal = currentHealth + amount
					if (heal > 1) then heal = 1 end
					Entity_SetHealth(entity, heal)
				end
				
				Util_SetAnimatorAction(entity, "ui\\abilities\\medkit")
			end
			
		end
	end
end

function Unit:Kill()
	SGroup_Kill(self.sgroup)
end

function Unit:GetBlueprintName()
	if (SGroup_CountSpawned(self.sgroup) > 0) then
		return Squad_GetBlueprintName(SGroup_GetSpawnedSquadAt(self.sgroup, 1))
	else
		PrintObject(self)
		fatal(tostring(self.data.name).." tried to GetBlueprintName() but had no spawned squads")
	end
end

function Unit:SetUnconscious(toggle)
	if (SGroup_CountSpawned(self.sgroup) > 0) then
		local squad = SGroup_GetSpawnedSquadAt(self.sgroup, 1)
		local numSquad = Squad_Count(squad)
		if (numSquad > 0) then
			for i=0, numSquad-1 do
				local entity = Squad_EntityAt(squad, i)
				Entity_SetUnconsciousEnabled(entity, toggle)
			end
		end
	end
end


function Unit:IncrementSimVariable(simVariable, number)
	if (SGroup_CountSpawned(self.sgroup) > 0) then
		self.simVariables = self.simVariables or { }
		self.simVariables[simVariable] = self.simVariables[simVariable] or 0
		self.simVariables[simVariable] = self.simVariables[simVariable] + number
		local newNumber = self.simVariables[simVariable]
		
		if (self.simVariables[simVariable] > 0) then
			simNumber = 1
		else
			simNumber = 0
		end
		
		local squad = SGroup_GetSpawnedSquadAt(self.sgroup, 1)
		for i=0, Squad_Count(squad)-1 do
			local entity = Squad_EntityAt(squad, i)
			Entity_SetSimVariable(entity, simVariable, simNumber)
		end
		
	end
end

function Unit:GetSimVariable(simVariable)
	self.simVariables = self.simVariables or { }
	
	if (self.simVariables[simVariable]) then
		return self.simVariables[simVariable]
	else
		if (SGroup_CountSpawned(self.sgroup) > 0) then
			local squad = SGroup_GetSpawnedSquadAt(self.sgroup, 1)
			local entity = Squad_EntityAt(squad, 0)
			self.simVariables[simVariable] = Entity_GetSimVariable(entity, simVariable)
			return self.simVariables[simVariable]
		else
			self.simVariables[simVariable] = 0
			return self.simVariables[simVariable]
		end
	end
	
end

