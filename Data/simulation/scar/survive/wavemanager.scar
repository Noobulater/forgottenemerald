
Util_LoadOnce("Survive//Wave.scar")
Util_LoadOnce("Survive//actionManager.scar")
WaveManager = {
	currentWave = 1,
	startMarkers = {
		"entry1",
		"entry2",
		"entry3",
		"entry4",
	},
	waveTimeMultiplier = {
		start = 3,
		decrement = 0.5,
		lastDecrement = 0,
		interval = 25,
	},
	waves = {},
	experienceReward = 100,
}

function WaveManager:CreateWaves(data)
	for k,v in pairs(data) do
		table.insert(self.waves, Wave:New(v))
	end
	
	Rule_AddOneShot(function() self:Start() end, 0)
end

function WaveManager:Start(wave)
	wave = wave or LastStand_GetStartingWave() or 1
	if(self.deathMultiplier)then
		return
	end	
	
	Survive.EventHandler:AddListener(self, "HeroKOStateChange")
	wave = wave or self.currentWave or 1
	
	if( wave > #self.waves )then
		wave = #self.waves
	end
		
	self.currentWave = wave
	
	self.deathMultiplier = ScoreBoard:AddMultiplier(0, 9115609)
	self.waveTimeMultiplier.multiplier = ScoreBoard:AddMultiplier(self.waveTimeMultiplier.start, 9115610)
	self:StartWave(wave)
	Rule_AddInterval(function() self:Update() end, 1)
end

function WaveManager:Update()
	local currentWave = self.waves[self.currentWave]
	local wm = self.waveTimeMultiplier
	
	if(currentWave:AllSpawned())then
		wm.lastDecrement = wm.lastDecrement or World_GetGameTime()
		
		local timerValue = (World_GetGameTime() - wm.lastDecrement) / wm.interval
		LastStand_UpdateWaveTimer( timerValue )
		
		if(World_GetGameTime() >= wm.lastDecrement + wm.interval)then
			local mp = wm.multiplier.multiplier
			local dec = wm.decrement
			local new = mp - dec
			
			if(new < 0)then
				new = 0
			end
			
			--new = string.format("%.1f", new)
	
				wm.multiplier.multiplier = new
				wm.lastDecrement = World_GetGameTime()
				
		end
	end

	local total = currentWave:TotalPoints() or 1
	if(total <= 0)then
		total = 1
	end
	local left = currentWave:PointsAlive() or 0
	local val = 1 - left / total
	
	if(val < 0 or val > 1)then
		val = 0
	end
	
	LastStand_SetWaveProgressValue( val )	
	
	if(currentWave:IsDead())then
		local exp = currentWave.data.experienceReward or self.experienceReward or 0
		LastStand_GrantExperience(exp)
		if (currentWave.endDelay) then
			Rule_AddOneShot(function()
				self:StartNextWave()
				Rule_AddInterval(function() self:Update() end, 1)
				print("DelayedStartNextWave "..tostring(World_GetGameTime()))
			end,currentWave.endDelay)
			Rule_RemoveMe()
			print("EndActionsStarted "..tostring(World_GetGameTime()))
		else
			print("StartNextWave "..tostring(World_GetGameTime()))
			self:StartNextWave()
		end
	end
	
end

function WaveManager:StartNextWave()
	self.currentWave = self.currentWave + 1
	
	if(self.currentWave <= #self.waves)then
		self:StartWave(self.currentWave)
	else
		print("GameEnd "..tostring(World_GetGameTime()))
		Game_EndSP(true)
	end
end	

function WaveManager:StartWave(wave)
	self:UpdateDeathMultiplier()
	self.waveTimeMultiplier.multiplier.multiplier = self.waveTimeMultiplier.start + (math.floor(self.currentWave / 4) * 0.5)
	self.waveTimeMultiplier.lastDecrement = nil

	self.currentWave = wave	
	self.waves[wave]:Start()
end

function WaveManager:Event(event, sender)
	if(event == "HeroKOStateChange" and sender.ko)then
		self:ResetDeathMultiplier(sender)
	end	
end

function WaveManager:UpdateDeathMultiplier()
	if (self.deathWaveOfLastPlayer ~= self.currentWave) then
		self.deathMultiplier.multiplier = self.deathMultiplier.multiplier + 1
	end
end

function WaveManager:GetWaveByID(id)
	for k,v in pairs(self.waves) do 
		if(v.id == id)then 
			return v
		end
	end
end

function WaveManager:ResetDeathMultiplier(sender)
	if (sender.ko) then
		self.deathMultiplier.multiplier = 1
		self.deathWaveOfLastPlayer = self.currentWave
	end
end

function WaveManager:RegisterUnit(unit)
	self.waves[self.currentWave]:RegisterUnit(unit)
end
