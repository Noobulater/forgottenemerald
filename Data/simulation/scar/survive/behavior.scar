Util_LoadOnce("Survive//Targeting.scar")
Util_LoadOnce("Survive//Requirement.scar")
Survive.Behavior = { }
Util_LoadOnce("Survive//Data//Behaviors.scar")

local Behavior = Survive.Behavior


Behavior.SquadStateCheck = {
	Idle = function(self, squadState)
		local squadState = squadState or Util_GetActiveSquadCommand(self.sgroup)
		if (not SGroup_IsMoving(self.sgroup, ANY)) and (squadState == SQUADSTATEID_Idle) then
			return true
		else
			return false
		end
	end,
	Combat = function(self, squadState)
		if (SGroup_IsDoingAttack(self.sgroup, true, 4)) or (SGroup_IsUnderAttack(self.sgroup, true, 6)) then
			return true
		else
			return false
		end
	end,
	Moving = function(self, squadState)
		local squadState = squadState or Util_GetActiveSquadCommand(self.sgroup)
		if (SGroup_IsMoving(self.sgroup, ANY) 
		and ((squadState == SQUADSTATEID_Move) or (squadState == SQUADSTATEID_AttackMove))) then
			return true
		else
			return false
		end
	end,
	Retreating = function(self, squadState)
		local squadState = squadState or Util_GetActiveSquadCommand(self.sgroup)
		if (squadState == SQUADSTATEID_Retreat) then
			return true
		else
			return false
		end
	end,
}

Behavior.transitionStates = {
	["idle"] = {
		transitions = {
			["combat"] = {
				priority = 3,
				canTransition = Behavior.SquadStateCheck.Combat,
			},
			["moving"] = {
				priority = 2,
				waitTime = 5,
				canTransition = Behavior.SquadStateCheck.Moving,
			},
			["retreating"] = {
				priority = 10,
				canTransition = Behavior.SquadStateCheck.Retreating,
			},
		},
	},
	["combat"] = {
		doNotTransition = Behavior.SquadStateCheck.Combat,
		transitions = {
			["idle"] = {
				priority = 1,
				waitTime = 4,
				canTransition = Behavior.SquadStateCheck.Idle,
			},
			["moving"] = {
				waitTime = 5,
				priority = 2,
				canTransition = Behavior.SquadStateCheck.Moving,
			},
			["retreating"] = {
				priority = 10,
				canTransition = Behavior.SquadStateCheck.Retreating,
			},
		},
	},
	["moving"] = {
		transitions = {
			["idle"] = {
				priority = 1,
				waitTime = 4,
				canTransition = Behavior.SquadStateCheck.Idle,
			},
			["combat"] = {
				priority = 3,
				canTransition = Behavior.SquadStateCheck.Combat,
			},
			["retreating"] = {
				priority = 10,
				canTransition = Behavior.SquadStateCheck.Retreating,
			},
		},
	},
	["retreating"] = {
		transitions = {
			["idle"] = {
				priority = 1,
				waitTime = 6,
				canTransition = Behavior.SquadStateCheck.Idle,
			},
		},
	},
}


function Behavior.StateUpdater(self)
	local states = Behavior.transitionStates
	if ((self.behavior.stateTime + self.behavior.stateWaitTime) <= World_GetGameTime()) then
		if ((states[self.behavior.state].doNotTransition == nil)
		or (states[self.behavior.state].doNotTransition(self) ~= true)) then
			local newStateTable = { }
			local newState
			local squadState = Util_GetActiveSquadCommand(self.sgroup)
			for k, v in pairs(states[self.behavior.state].transitions) do
				if (v.canTransition(self, squadState)) then
					if (type(newState) == "string")
					and (v.priority < newStateTable.priority) then
						-- Do Nothing
					else
						newStateTable = v
						newState = k
						self.behavior.stateChanged = true
					end
				end
			end
--~ 			if (newState) then
--~ 				print(self.data.name.." Old State: "..tostring(self.behavior.state).." -> New State: "..tostring(newState))
--~ 			end
			self.behavior.state = newState or self.behavior.state
			self.behavior.stateTime = World_GetGameTime()
			self.behavior.stateWaitTime = newStateTable.waitTime or 0
		end
		self.behavior.stateTime = World_GetGameTime()
		self.behavior.stateWaitTime = 0
		Behavior.RunBehaviors(self)
		self.behavior.stateChanged = false
	end
	
end

function Behavior.FireAbilities(self, params)
	if (type(self.data.abilities) == "table") then
		for k, v in pairs(self.data.abilities) do
			local squad = SGroup_GetRandomSpawnedSquad(self.sgroup)
			v.energyCost = v.energyCost or Misc_GetAbilityEnergyCost(v.blueprint, squad)
			if (SGroup_GetEnergy(self.sgroup) >= v.energyCost) then
				if (not v.abilityBehavior) or (v.abilityBehavior == params.abilityBehavior) then
					if (type(v.target) == "table")
					and (type(Survive.Targeting[v.target.name]) == "function") then
						local target = Survive.Targeting[v.target.name](self, v.target)
						if (target) and (Survive.Requirement.Check(self, target, v.requirements)) then
							Cmd_Ability(self.sgroup, v.blueprint, target)
							self.behavior.stateWaitTime = v.waitTime or 1
							return true
						end
					elseif (Survive.Requirement.Check(self, target, v.requirements)) then
						Cmd_Ability(self.sgroup, v.blueprint)
						self.behavior.stateWaitTime = v.waitTime or 1
						return true
					end
				end
			end
		end
		self.behavior.stateWaitTime = World_GetRand(1, 4)
		return false
	end
end

function Behavior.FireAbilitiesDebug(self, params)
	if (type(self.data.abilities) == "table") then
		for k, v in pairs(self.data.abilities) do
			v.squad = SGroup_GetRandomSpawnedSquad(self.sgroup)
			v.energyCost = v.energyCost or Misc_GetAbilityEnergyCost(v.blueprint, v.squad)
			print(tostring(v.name).." costs "..v.energyCost.." "..tostring(self.data.name).." has "..SGroup_GetEnergy(self.sgroup).." energy")
			if (SGroup_GetEnergy(self.sgroup) >= v.energyCost) then
				if (not v.abilityBehavior) or (v.abilityBehavior == params.abilityBehavior) then
					if (type(v.target) == "table")
					and (type(Survive.Targeting[v.target.name]) == "function") then
						local target = Survive.Targeting[v.target.name](self, v.target)
						if (target) and (Survive.Requirement.CheckDebug(self, target, v.requirements)) then
							print(tostring(self.data.name).." used ability "..tostring(v.name).." at "..World_GetGameTime())
							print("The ability had a target")
							local casterPos = Util_GetPosition(self.sgroup)
							local targetPos = Util_GetPosition(target)
							print("Caster Location: x = "..casterPos.x.." z = "..casterPos.z.." y = "..casterPos.y)
							print("Target Location: x = "..targetPos.x.." z = "..targetPos.z.." y = "..targetPos.y)
							print("Total Distance = "..World_DistancePointToPoint(casterPos, targetPos))
							Cmd_Ability(self.sgroup, v.blueprint, target)
							self.behavior.stateWaitTime = v.waitTime or 3
							return true
						else
							print("Target "..v.target.name.." = "..tostring(target))
							print("Requirement = "..tostring(Survive.Requirement.CheckDebug))
							print(tostring(v.name).." did not meet requirements or could not find a target")
						end
					elseif (Survive.Requirement.CheckDebug(self, target, v.requirements)) then
						print(tostring(self.data.name).." used ability "..tostring(v.name).." at "..World_GetGameTime())
						print("Ability had no need for a target!")
						Cmd_Ability(self.sgroup, v.blueprint)
						self.behavior.stateWaitTime = v.waitTime or 3
						return true
					else
						print(tostring(Survive.Requirement.CheckDebug))
						print(tostring(v.name).." did not meet requirements")
					end
				end
				print(tostring(v.abilityBehavior).." vs. "..tostring(params.abilityBehavior).." failed")
			end
		end
		local waittime = World_GetRand(1, 4)
		self.behavior.stateWaitTime = waittime
		print("Added a wait time of "..waittime.." seconds")
		return false
	end
end

function Behavior.FireToggleAbilities(self, params, currentState)
	for k, v in pairs(params.toggleAbilities) do
		if ((v.toggleOn == currentState) and (self[v.id]  == false)) then
			local target = nil
			if (Survive.Requirement.Check(self, target, v.requirements)) then
				Cmd_Ability(self.sgroup, v.blueprint, target, true)
				self[v.id] = true
			end
		elseif ((v.toggleOn ~= currentState) and (self[v.id]  == true)) then
			local target = nil
			Cmd_Ability(self.sgroup, v.blueprint, target, true)
			self[v.id] = false
		end
	end
end

function Behavior.RetreatSquad(self, params)
	local health = SGroup_GetAvgHealth(self.sgroup)
	local percent = params.percent or 0.4
	
	if (health < percent) then
		if (self.retreatLocation) then
			Cmd_RetreatToLocation(self.sgroup, self.retreatLocation)
			self.retreatLocation = Survive.Room.GetRoomPlayerIsNotIn(self.room)
			self.retreatLocation = self.retreatLocation:GetPosition()
			self.behavior.state = "retreating"
		else
			Cmd_Retreat(self.sgroup)
			self.behavior.state = "retreating"
		end
	end
end

function Behavior.RunBehaviors(self)
	for k, v in pairs(self.behaviorList) do
		if (type(v) == "table") and (type(v.name) == "string") then
			Behavior.Execute(self, v.name, v)
		end
	end
end

function Behavior.SendCommand(self, ...)
   	for k, v in pairs(self.behaviorList) do
		if (type(v) == "table") and (type(v.name) == "string") then
            local behavior = Behavior.GetFromName(v.name)
            if(type(behavior.command) == "function")then
                behavior.command(self, ...)
            end
		end
	end 
end

function Behavior.GetFromName(name)
    local behavior = Behavior[name]
	if (type(behavior) == "table") then
		return behavior
	end
end

function Behavior.AddBehavior(self, behaviorData)
	self.behaviorList = self.behaviorList or { }
	local behaviorData = Clone(behaviorData)
	for k, v in pairs(self.behaviorList) do
		if (v.name == behaviorData.name) 
		and (not (behaviorData.unique)) 
		and (v.abilityBehavior == behaviorData.abilityBehavior) then
			v = behaviorData
			return
		end
	end
	table.insert(self.behaviorList, 1, behaviorData)
	if (type(Behavior[behaviorData.name]["onInit"]) == "function") then
		Behavior[behaviorData.name]["onInit"](self, behaviorData)
	end
end

function Behavior.RemoveBehavior(self, behaviorName)
	self.behaviorList = self.behaviorList or { }
	for k, v in pairs(self.behaviorList) do
		if (behaviorName == behaviorData.name) then
			v = nil
		end
	end
end

function Behavior.Execute(self, behavior, params)
	if (type(Behavior[behavior]) == "table") 
	and (type(Behavior[behavior][self.behavior.state]) == "function") 
	and (Survive.Requirement.Check(self, behavior, params.requirements) == true) then
		Behavior[behavior][self.behavior.state](self, params, behavior)
	end
end

function Behavior.InitBehavior(self, ruleDelay, ruleTime)
	local _behavior = function()
		if (type(self) == "nil") or (Util_CountSpawned(self.sgroup) == 0) then
			Rule_RemoveMe()
		else
			Behavior.StateUpdater(self)
		end
	end
	
	local _runBehavior = function()
		Rule_AddInterval(_behavior, ruleTime)
	end
	
	if (type(self.behaviorList) == "table")
	and (type(self.behaviorList[1]) == "table") then
		Rule_AddOneShot(_runBehavior, ruleDelay)
		self.behavior = { }
		self.requirementData = { }
		self.behavior.state = self.behavior.state or "idle"
		self.behavior.stateTime = self.behavior.stateTime or World_GetGameTime()
		self.behavior.stateWaitTime = self.behavior.stateWaitTime or 0
		
		for k, v in pairs(self.behaviorList) do
			if (type(Behavior[v.name]) == "table") then
				if (type(Behavior[v.name].onInit) == "function") then
					Behavior[v.name].onInit(self, v)
				end
			else
				fatal("Bad Behavior Set up on "..tostring(self.data.name).." of behavior name "..tostring(v.name))
			end
		end
		
	else
		print("Failed to set up behaviors for "..tostring(self.data.name).."at "..World_GetGameTime().." seconds"..
		"\n Chances are it did not have a behaviorList")
	end
end
